  
## 为什么要使用

* 缓冲 和 削峰： 上游数据 时有 突发流量，下游 可能扛不住，或者 下游 没有 足够多的机器 来保证冗余，kafka 在中间可以起到一个缓冲的作用，把消息 暂存在 kafka 中，下游服务 就可以按照自己的节奏 进行慢慢处理。 

* 健壮性： 消息队列 可以 堆积请求，所以 消费端 业务 即使 短时间 死掉，也不会 影响 主要业务 的 正常进行。 

* 异步通信： 很多时候，用户 不想 也不需要 立即处理消息。  消息队列 提供了 异步处理机制，允许用户 把一个消息 放入队列，但并不立即 处理它。想向队列中 放入多少消息 就放多少，然后在需要的时候 再去处理它们。   





* 解耦 和 扩展性：    项目开始的时候， 并不能确定 具体需求。消息队列 可以作为 一个 接口层，解耦 重要的 业务流程。  只需要 遵守约定，针对 数据编程 即可获取 扩展能力。  

* 冗余：   可以 采用 一对多的方式，一个生产者 发布消息，可以 被    多个订阅 topic 的   服务   消费到，      供多个 毫无关联的 业务 使用。  









## kafka 中 的 zookeeper 起到什么作用，可以不用 zookeeper 么

zookeeper 是 一个 分布式的协调组件，早期版本的 kafka 用 zk 做 
meta 信息 存储，
consumer 的 消费状态，
group 的管理 
以及 offset 的值。  

考虑到 zk 本身的 一些因素 
以及 整个架构 较大概率 存在 单点问题，新版本中 逐渐弱化了 zookeeper 的作用。  

新的 consumer 使用了 kafka 内部的 group coordination 协议，也减少了 对 zookeeper 的依赖，

但是 broker 依然 依赖于 ZK，
zookeeper 在 kafka 中 还 用来 选举 controller 和 检测 broker 是否 存活等等。









## kafka producer 如何优化 打入速度

1. 增加 线程
2. 提高 batch.size
3. 增加 更多 producer 实例
4. 增加 partition 数
5. 设置 acks=-1 时，  如果延迟增大：  可以增大 num.replica.fetchers（follower 同步数据 的 线程数） 来 调解；
6. 跨数据中心 的 传输： 增加 socket 缓冲区 设置   以及 OS tcp 缓冲区 设置。







## kafka 的 message 格式是什么样的

一个 Kafka 的 Message 由 一个固定长度的 header 和 一个 变长的消息体 body 组成

header 部分由
一个字节的 magic(文件格式) 和 
四个字节的 CRC32 （用于判断 body 消息体 是否正常） 构成。
当 magic 的值为 1 的时候，会在 magic 和 crc32 之间多一个字节的数据： attributes（保存一些相关属性，比如是否压缩、压缩格式等等）;
如果 magic 的值为 0，那么不存在 attributes 属性

body 是由 N 个字节构成的一个消息体，包含了具体的 key/value 消息










## Kafka 中 的 消息 是否会 丢失 和 重复消费？

针对 消息丢失：

同步模式下，确认机制 设置为 -1，即 让消息写入 Leader 和 Follower 之后 再 确认消息 发送成功；  
异步模式下，为防止 缓冲区满，可以在 配置文件 设置 不限制 阻塞超时时间，      当 缓冲区满时 让生产者一直处于 阻塞状态；



针对 消息重复：  

将 消息的唯一标识  保存到 外部介质中，每次消费时 判断 是否 处理过 即可。     








## Kafka 中是 怎么体现 消息 顺序性的？

kafka 每个 partition 中 的 消息 在写入时 都是有序的，  
消费时，每个 partition 只能 被每一个 group 中 的一个消费者 消费，
保证了 消费时 也是有序的。
整个 topic 不保证有序。  如果为了保证 topic 整个有序，那么 将 partition 调整为1.

