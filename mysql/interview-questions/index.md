
如无备注，则表中的 第一个 id 字段 一定是 主键 且为 自动增长；

数据表 必须 有主键，且建议 均 使用 auto_increment 的 id 作为主键（与业务无关）,  
和 业务相关的 要做为 唯一索引；


假设我们有张表，结构如下：  

```
create table user(
  id int(11) not null,
  age int(11) not null,
  primary key(id),
  key(age)
);

```




## 聚簇 和 非聚簇 索引

索引 按照 数据结构 来说 主要包含 B+ 树 和 Hash 索引。  


B+ 树是 左小右大 的 顺序 存储结构， 节点只包含 id 索引列， 而 叶子节点 包含 索引列和数据，
这种 数据和索引 在一起存储的 索引方式 叫做聚簇索引，  

一张表 只能有 一个 聚簇索引。假设 没有 定义主键，InnoDB 会选择 一个唯一的 非空索引代替，如果没有的话 则会隐式定义 一个主键 作为 聚簇索引。  


非聚簇索引(二级索引) ：    
保存的是 主键 id 值，  
这一点和 myisam 保存的是 数据地址 是不同的。  



## 什么是覆盖索引和回表

覆盖索引 指的是 在一次查询中，如果一个索引  包含或者说覆盖  所有 需要查询的字段 的值，我们就称之为 覆盖索引，而不再需要回表查询。

而要确定一个查询  是否是  覆盖索引，我们只需要 explain sql 语句看 Extra 的结果是否是 “Using index” 即可。

以上面的 user 表来举例，我们再增加一个 name 字段，然后做一些查询试试。
`explain select * from user where age=1;` // 查询的 name 无法从索引数据获取 
`explain select id,age from user where age=1;` // 可以直接从索引获取
  




## 为搜索字段建索引  

索引 并不一定就是 给 主键 或是 唯一的字段。如果在你的表中，有某个字段 你会经常 用来做搜索，那么可以为其建立索引。

什么样的搜索 是不能 使用 正常的索引的。
例如，当你需要在一篇大的文章中 搜索一个词时，如 `WHERE post_content LIKE ‘%apple%'` 索引可能是没有意义的。
你可能需要使用 MySQL 全文索引 或是自己做一个索引，比如说 搜索关键词 或是 Tag 什么的  






## MySQL 的索引是不是越多越好

从存储结构来说，索引多了后 占磁盘的存储量 也会大，存在维护 以及 成本开销  

从一些 crud 来说，索引多了后，进行删除，新增 以及 修改时 会涉及 多个索引树 的变更，导致 SQL 执行速度变慢  

从锁来说，在 RR 的 事务隔离级别下，由于 next-key lock 的作用  避免了 幻读，但是 有可能 导致 对多个事务分别同时 对多个数据 进行变更时 导致死锁     





### 数据库索引设计规范

1.限制 每张表上 的索引数量，建议 单张表 索引 最好不超过 5 个，如果超过 5 个 说明 表设计 过大。
2.索引 并不是 越多越好。索引 可以 提高 查询的效率，但会 降低 写数据的 效率。有时不好的索引 还会降低 查询的效率。多使用 explain。
3.禁止给表中的每一列 都建立单独的索引。设计良好的联合索引 比每一列上的单独索引 效率要高出很多。
4.每个 Innodb 表 都必须有 一个主键，且不使用 更新频繁的列 作为主键，不使用多列主键。不使用 UUID、MD5、字符串列 作为主键。最好选择值的顺序是连续增长的列作为主键，所以建议选择使用自增 ID 列作为主键  

5.建议在下面的列上建立索引：
- 在SELECT，UPDATE，DELETE语句的WHERE从句上的列。
- 在ORDERBY，GROUP BY，DISTINCT上的列。多表JOIN的关联列。
- 区分度最高的列放在联合索引的最左侧。使用频繁的列放在联合索引的最左侧。
- 避免冗余的索引，如：primary key(id)，index(id)，unique index(id)
- 避免重复的索引，如：index(a%2Cb%2Cc)，index(a%2Cb)，index(a)
- 重复的和冗余的索引会降低查询效率，因为MySQL查询优化器会不知道该使用哪个索引。
