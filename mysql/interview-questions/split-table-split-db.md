


## 分库 分表

首先 分库 分表 分为 垂直 和 水平 两个方式，一般来说 我们拆分的顺序 是  先垂直  后水平。

垂直分库： 基于 现在 微服务 拆分来说，都是已经做到了   垂直分库了。  
垂直分表： 如果 表字段 比较多，将  不常用的、数据较大的   等等做拆分。  

水平分表  
首先根据 业务场景 来决定 使用什么字段 作为 分表字段（sharding_key），  
比如我们现在日订单 1000 万，我们大部分的场景 来源于 C 端，我们可以用 user_id 作为 sharding_key，
数据查询 支持到 最近 3 个月 的订单，超过 3 个月的 做归档处理，那么 3 个月 的数据量就是 9 亿，可以分 1024 张表，那么每张表的数据 大概就在 100 万左右。

比如用户 id 为 100，那我们都经过 hash(100)，然后对 1024 取模，就可以 落到 对应的表 上了。




## 那分表后的 ID 怎么 保证 唯一性 的呢？

因为我们主键 默认 都是 自增的，那么 分表之后的 主键 在不同表 就肯定会有冲突了。有几个办法考虑：   

1. 设定步长，比如 1-1024 张表 我们分别设定 1-1024 的 基础步长，这样主键 落到不同的表 就不会冲突了。  
2. 分布式ID，自己实现 一套分布式ID生成算法 或者 使用开源的 比如雪花算法 这种。  
3. 分表后 不使用主键 作为查询依据，而是 每张表 单独 新增一个字段 作为 唯一主键 使用，比如  订单表订单号  是唯一的，不管最终落在哪张表  都基于订单号   作为查询依据，更新也一样。   





## 分表后非 sharding_key 的查询 怎么处理呢？

可以做一个 mapping 表，比如这时候 商家要 查询订单 列表 怎么办呢？  
不带 user_id 查询的话 你总不能 扫全表吧？所以我们可以做 一个映射关系表，保存商家和用户的关系，查询的时候 先通过商家查询到用户列表，再通过 user_id 去查询。    

打宽表，一般而言，商户端 对数据实时性 要求并不是很高，比如 查询订单列表，可以把 订单表 同步到 离线（实时）数仓，
再基于数仓 去做成 一张宽表，再基于 其他如 es 提供查询服务。  

数据量不是很大的话，比如后台的 一些查询之类的，也可以通过 多线程 扫表，然后 再聚合结果的方式 来做。
或者异步的形式也是可以的。  





4. 预估 表数据量，如果 数据量较大（超过500w）则需要 考虑 分表策略。   可以 等量均衡分表 或 根据 业务规则分表 均可。   
要分表的数据表 必须与 DBA 商量 分表策略；   

3.控制单表 数据量 的大小，建议 控制在 500万行 以内。