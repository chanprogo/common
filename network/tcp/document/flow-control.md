



早期的 流量控制模式—— 停止-等待 模式 (stop-wait)

顾名思义 就是 发送方 在发送一个数据包后 就停止发送，等待对方响应 ACK，
然后才能 继续发送数据。  
这种模式的具体实现为 Positive Acknowledgment With Retransmission (PAR)，意为 带重传的 肯定确认协议  


这种实现很简单，发送方 在发送数据包 时  会设置一个计时器，然后等待 接收方的 ACK，
接收方 在收到数据后 会返回 ACK 作为应答，发送方 在收到 ACK 后 会发送下一个数据包。  
如果由于网络原因 造成数据包 或者 ACK 丢失时，计时器会超时，然后发送方会重新发送未被确认的数据包。  

可以看到，这种模式 虽然可以确保数据传输的 可靠性，但是有个 致命的缺点，那就是效率太低？  

如果是你，你会怎么 对这个方案进行优化呢？







既然 每次 只发送一个数据包 效率太低，  
那就 多发送几个，然后给这些数据包 编上号，接收端 必须对每一个包进行确认，  

这样设备 A 一次多发送几个片段，而不必等候 ACK，
同时接收端 也要告知 它能够 收多少，这样发送端发起来也有个限制，  

当然还需要保证顺序性，不要乱序，
对于乱序的状况，我们可以允许 等待一定 情况下的乱序，比如说  先缓存  提前到的数据，然后去等待需要的数据，  

如果一段时间没来 就丢掉乱序的数据，来保证顺序性，
这样的话，数据传输效率 就可以大大提高。  
不过 TCP 也没有 采用这种方案，而是在此基础上 实现更加复杂的 滑动窗口。   









## 发送缓存中的字节分类

第一类：已发送且已确认，这些数据已经发送成功 并已经被确认的数据，
这些数据其实的位置是在窗口之外了，下一步 将 被移出 发送缓存。
窗口内 顺序最低的字节 被确认之后，窗口左边界 会向右移动，称为 窗口合拢。  

第二类：已发送但未收到确认，这部分数据 已经被发送出去，但是还没有收到接收端的 ACK，认为并没有完成发送，这部分数据 属于窗口内的数据。  

第三类：未发送但是接收方已经准备好接收，这部分是 尽快发送的数据，这部分数据已经被加载到 缓存中，也在发送窗口中，正在等待发送，
其实这个窗口 是完全有接收方 告知的，接收方 告知当前可以接受 这些数据，所以发送方 需要尽快的发送。  

第四类：未发送且接收方未准备好接收，这些数据属于 未发送，同时接收端也不允许发送的，因为这些数据已经超出了发送端 所接收的范围。  




发送窗口 的大小由两个因素决定：  
1. 接收方的提供的窗口大小 (TCP 报文段首部中的 window 字段)，发送方在三次握手阶段首次得到这个值，之后的通信过程中接收方会根据自己的可用缓存对这个值进行动态调整；  
2. 发送方会根据网络情况维护一个拥塞窗口变量 (后文介绍)。  

发送窗口的大小取这两个值的最小值。   

对于发送方来说，发送窗口分为两部分：
1. 已经发送的部分（已经发送了，但是没有收到ACK）
2. 可用窗口，即接收端允许发送但是没有发送的那部分。  

接收窗口：  
对于接收端也是有一个接收窗口的，类似发送端，接收端的数据有3个分类，因为接收端并不需要 等待 ACK 所以它没有类似的 接收并确认了的分类，情况如下  
1. Received and ACK     Not Send to Process：这部分数据属于接收了数据 但是还没有被上层的应用程序 接收；  
2. Received Not ACK:                         已经接收，但是还没有回复 ACK；  
3. Not Received：                            有空位，还没有被接收的数据。  








