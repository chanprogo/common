
## 基于 TCP 协议下，如何 将 内核缓冲区 的 数据 主动 发出去  


问题中 特定了 内核 缓冲区，即是  内核 驱动网卡 发数据 的动作。  

基于 TCP/IP 协议族 的 分层定义，每台 PC 的 网卡  会抽象成  传输层，   
所以 转化过来 即是 主动 让 传输层 的 缓冲区 发出去，  而 不用 等到 缓冲区 满了 才主动发出。  
也就说 要修改 TCP 协议中  发送方  发送数据的 机制，就可以解决这个问题。


而 TCP 协议中，因为 如果只要有数据 就发送给 接受方。会导致 大量的小数据 在网络上 导致阻塞，所以会 默认开启 nagle 算法，   
当 TCP 报文段 达到一定长度 才会送。

所以关闭 nagle 算法（TCP_NODELAY）关闭后，就能够 有数据时 马上发送。  






## TCP 粘包和拆包的原因

我们知道 TCP 是以字节流的方式传输数据，传输的最小单位为一个报文段（segment）。  
TCP 首部 中 有个选项 (Options)的字段，常见的选项为 MSS （Maximum Segment Size 最大消息长度），它是收发双方协商通信时 每一个报文段 所能承载的 最大有效数据的长度。  
数据链路层 每次传输的数据 有个最大限制 MTU （Maximum Transmission Unit），一般是 1500 字节，超过这个量要分成多个报文段，    
MSS 则是这个最大限制减去 TCP 的首部，光是 要传输的数据的大小，一般为1460字节。  
MSS = MTU - Header  

TCP 为提高性能，发送端 会将需要发送的数据 发送到发送缓存，等待 缓存满了之后，再将缓存中的数据 发送到接收方。  
同理，接收方也有接收缓存 这样的机制，来接收数据。  


上面这些是发生 TCP 粘包和拆包的前提，下面是具体的原因：    
1. 要发送的数据 大于 TCP 发送缓冲区 剩余空间大小，将会发生拆包。  
2. 待发送数据 大于MSS（最大报文长度），TCP 在传输前 将进行拆包。  
3. 应用程序 写入数据 小于 剩余缓存大小，网卡 将应用多次写入的数据 先缓存起来，然后一起 发送到网络上，这将会发生粘包。  
4. 接收数据端 的应用层 没有及时读取 接收缓存中 的数据，将发生粘包。  
  
