
## 分库 分表

首先 分库 分表 分为 垂直 和 水平 两个方式，一般来说 我们拆分的顺序 是  先垂直  后水平。

垂直分库： 基于 现在 微服务 拆分来说，都是已经做到了   垂直分库了。  
垂直分表： 如果 表字段 比较多，将  不常用的、数据较大的   等等做拆分。  


水平分表  

首先 根据 业务场景 来决定 使用什么字段 作为 分表字段（sharding_key），  
比如 我们 现在 日订单 1000 万，我们 大部分的场景 来源于 C 端，我们可以用 user_id 作为 sharding_key，
数据查询 支持到 最近 3 个月 的订单，超过 3 个月的 做归档处理，那么 3 个月 的数据量就是 9 亿，可以分 1024 张表，那么每张表的数据 大概就在 100 万左右。

比如用户 id 为 100，那我们都经过 hash(100)，然后对 1024 取模，就可以 落到 对应的表 上了。




## 那分表后的 ID 怎么 保证 唯一性 的呢？

因为我们主键 默认 都是 自增的，那么 分表之后的 主键 在不同表 就肯定会有冲突了。有几个办法考虑：   

1. 设定步长，比如 1-1024 张表 我们分别设定 1-1024 的 基础步长，这样主键 落到不同的表 就不会冲突了。  
2. 分布式ID，自己实现 一套分布式ID生成算法 或者 使用开源的 比如雪花算法 这种。  
3. 分表后 不使用主键 作为查询依据，而是 每张表 单独 新增一个字段 作为 唯一主键 使用，比如  订单表订单号  是唯一的，不管最终落在哪张表  都基于订单号   作为查询依据，更新也一样。   


